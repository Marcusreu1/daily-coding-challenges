# 264. Ugly Number II
# Difficulty: Medium
# https://leetcode.com/problems/ugly-number-ii/

"""
PROBLEM:
An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.
Given an integer n, return the nth ugly number.

EXAMPLES:
Input: n = 10  → Output: 12
Input: n = 1   → Output: 1

The sequence: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20, 24, 25, ...

CONSTRAINTS:
- 1 <= n <= 1690

KEY INSIGHT:
Every ugly number (except 1) is generated by multiplying a previous
ugly number by 2, 3, or 5. Use three pointers to track which ugly
number should be multiplied by each factor next.

ALGORITHM (Three Pointers / DP):
1. Start with ugly = [1]
2. Maintain three pointers p2, p3, p5 (all start at 0)
3. For each new ugly number:
   - next2 = ugly[p2] × 2
   - next3 = ugly[p3] × 3
   - next5 = ugly[p5] × 5
   - Add min(next2, next3, next5) to ugly
   - Advance pointer(s) that produced the minimum
4. Return ugly[n-1]

WHY THIS WORKS:
We're essentially merging three sorted sequences:
- ugly[0]×2, ugly[1]×2, ugly[2]×2, ...
- ugly[0]×3, ugly[1]×3, ugly[2]×3, ...
- ugly[0]×5, ugly[1]×5, ugly[2]×5, ...
Taking the minimum at each step ensures sorted order.
"""

# STEP 1: Initialize ugly array with 1 and three pointers
# STEP 2: Generate n ugly numbers using three pointers
# STEP 3: Take minimum of three candidates, advance matching pointers
# STEP 4: Return nth ugly number

class Solution:
    def nthUglyNumber(self, n: int) -> int:
        
        ugly = [0] * n                                                           # Preallocate array
        ugly[0] = 1                                                              # First ugly number is 1
        
        p2 = p3 = p5 = 0                                                         # Three pointers
        
        for i in range(1, n):
            
            next2 = ugly[p2] * 2                                                 # Candidate from ×2 sequence
            next3 = ugly[p3] * 3                                                 # Candidate from ×3 sequence
            next5 = ugly[p5] * 5                                                 # Candidate from ×5 sequence
            
            next_ugly = min(next2, next3, next5)                                 # Take minimum
            ugly[i] = next_ugly
            
            # Advance ALL pointers that produced the minimum (avoid duplicates)
            if next_ugly == next2:
                p2 += 1
            if next_ugly == next3:
                p3 += 1
            if next_ugly == next5:
                p5 += 1
        
        return ugly[n - 1]                                                       # Return nth (0-indexed: n-1)


"""
WHY EACH PART:
- ugly = [0] * n: Preallocate array for efficiency
- ugly[0] = 1: Base case - 1 is the first ugly number
- p2 = p3 = p5 = 0: All pointers start at first ugly number
- next2 = ugly[p2] * 2: Next candidate from multiplying by 2
- next3 = ugly[p3] * 3: Next candidate from multiplying by 3
- next5 = ugly[p5] * 5: Next candidate from multiplying by 5
- min(next2, next3, next5): Choose smallest to maintain sorted order
- if next_ugly == next2: p2 += 1: Advance pointer if it produced min
- Multiple if (not elif): Handle when multiple produce same value
- return ugly[n-1]: Array is 0-indexed

HOW IT WORKS (First 10 ugly numbers):

┌─────┬──────┬────────────────────┬─────────────┬───────────────┐
│ i   │ ugly │ next2, next3, next5│ min → ugly[i]│ p2, p3, p5   │
├─────┼──────┼────────────────────┼─────────────┼───────────────┤
│ 0   │ [1]  │                    │             │ 0, 0, 0       │
├─────┼──────┼────────────────────┼─────────────┼───────────────┤
│ 1   │      │ 2, 3, 5            │ 2           │ 1, 0, 0       │
│ 2   │      │ 4, 3, 5            │ 3           │ 1, 1, 0       │
│ 3   │      │ 4, 6, 5            │ 4           │ 2, 1, 0       │
│ 4   │      │ 6, 6, 5            │ 5           │ 2, 1, 1       │
│ 5   │      │ 6, 6, 10           │ 6 (p2,p3++) │ 3, 2, 1       │
│ 6   │      │ 8, 9, 10           │ 8           │ 4, 2, 1       │
│ 7   │      │ 10, 9, 10          │ 9           │ 4, 3, 1       │
│ 8   │      │ 10, 12, 10         │ 10 (p2,p5++)│ 5, 3, 2       │
│ 9   │      │ 12, 12, 15         │ 12 (p2,p3++)│ 6, 4, 2       │
├─────┼──────┼────────────────────┼─────────────┼───────────────┤
│     │ [1,2,3,4,5,6,8,9,10,12]  │             │               │
└─────┴──────┴────────────────────┴─────────────┴───────────────┘

ugly[9] = 12 ✓

WHY THREE POINTERS WORK (Merge Concept):
┌────────────────────────────────────────────────────────────┐
│  Sequence ×2:  2, 4, 6, 8, 10, 12, 16, 18, 20, 24, ...     │
│                ↑                                           │
│               p2 points here                               │
│                                                            │
│  Sequence ×3:  3, 6, 9, 12, 15, 18, 24, 27, 30, ...       │
│                   ↑                                        │
│                  p3 points here                            │
│                                                            │
│  Sequence ×5:  5, 10, 15, 20, 25, 30, 40, ...             │
│                ↑                                           │
│               p5 points here                               │
│                                                            │
│  We're merging these three INFINITE sorted sequences!      │
│  At each step, we pick the smallest unpicked element.      │
└────────────────────────────────────────────────────────────┘

WHY ADVANCE MULTIPLE POINTERS:
┌────────────────────────────────────────────────────────────┐
│  Example: When generating 6                                │
│                                                            │
│  next2 = ugly[2] × 2 = 3 × 2 = 6                          │
│  next3 = ugly[1] × 3 = 2 × 3 = 6                          │
│  next5 = ugly[1] × 5 = 2 × 5 = 10                         │
│                                                            │
│  Both p2 and p3 produce 6!                                 │
│                                                            │
│  If we only advance p2:                                    │
│    Next iteration: next3 still = 6 → DUPLICATE!           │
│                                                            │
│  We must advance BOTH p2 and p3 to skip both 6s.          │
└────────────────────────────────────────────────────────────┘

ALTERNATIVE SOLUTION (using heap):

import heapq

class Solution:
    def nthUglyNumber(self, n: int) -> int:
        heap = [1]
        seen = {1}
        ugly = 1
        
        for _ in range(n):
            ugly = heapq.heappop(heap)
            
            for factor in [2, 3, 5]:
                new_ugly = ugly * factor
                if new_ugly not in seen:
                    seen.add(new_ugly)
                    heapq.heappush(heap, new_ugly)
        
        return ugly

# Time: O(n log n) due to heap operations
# Space: O(n) for heap and set
# Three-pointer solution is more efficient: O(n) time, O(n) space

ALTERNATIVE SOLUTION (using set for dedup):

class Solution:
    def nthUglyNumber(self, n: int) -> int:
        ugly = [1]
        seen = {1}
        p2 = p3 = p5 = 0
        
        while len(ugly) < n:
            next2 = ugly[p2] * 2
            next3 = ugly[p3] * 3
            next5 = ugly[p5] * 5
            
            next_ugly = min(next2, next3, next5)
            
            if next_ugly not in seen:
                ugly.append(next_ugly)
                seen.add(next_ugly)
            
            if next_ugly == next2: p2 += 1
            if next_ugly == next3: p3 += 1
            if next_ugly == next5: p5 += 1
        
        return ugly[-1]

MATHEMATICAL INSIGHT:
┌────────────────────────────────────────────────────────────┐
│  Every ugly number can be written as:                      │
│                                                            │
│       ugly = 2^a × 3^b × 5^c    (a, b, c ≥ 0)             │
│                                                            │
│  The sequence is all possible combinations of a, b, c      │
│  sorted in ascending order:                                │
│                                                            │
│  (0,0,0) → 1                                               │
│  (1,0,0) → 2                                               │
│  (0,1,0) → 3                                               │
│  (2,0,0) → 4                                               │
│  (0,0,1) → 5                                               │
│  (1,1,0) → 6                                               │
│  (3,0,0) → 8                                               │
│  (0,2,0) → 9                                               │
│  (1,0,1) → 10                                              │
│  (2,1,0) → 12                                              │
│  ...                                                       │
└────────────────────────────────────────────────────────────┘
EDGE CASES:
- n = 1: Returns 1 ✓
- n = 2: Returns 2 ✓
- n = 7: Returns 8 (not 7, since 7 is not ugly) ✓
- n = 1690: Returns 2123366400 (largest for constraint) ✓

VERIFICATION TABLE:
┌───────┬─────────┬────────────────────────────────────┐
│   n   │ ugly[n] │           Factorization            │
├───────┼─────────┼────────────────────────────────────┤
│   1   │    1    │  1                                 │
│   2   │    2    │  2                                 │
│   3   │    3    │  3                                 │
│   4   │    4    │  2²                                │
│   5   │    5    │  5                                 │
│   6   │    6    │  2 × 3                             │
│   7   │    8    │  2³                                │
│   8   │    9    │  3²                                │
│   9   │   10    │  2 × 5                             │
│  10   │   12    │  2² × 3                            │
│  11   │   15    │  3 × 5                             │
│  15   │   24    │  2³ × 3                            │
│  20   │   36    │  2² × 3²                           │
└───────┴─────────┴────────────────────────────────────┘

TIME COMPLEXITY: O(n)
- Single loop from 1 to n
- Each iteration does O(1) work
- Total: O(n)

SPACE COMPLEXITY: O(n)
- Array to store n ugly numbers
- Three integer pointers (constant)

CONCEPTS USED:
- Dynamic Programming
- Three Pointers / Multiple Pointers
- Merging Sorted Sequences
- Generating vs. Checking approach
- Avoiding duplicates with multiple pointer advancement
"""
